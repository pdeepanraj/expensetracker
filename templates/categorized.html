
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Categorized CSV | Expense Analyzer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="/static/styles.css" rel="stylesheet">
  <style>
    tr.selected { background-color: rgba(34, 197, 94, 0.15) !important; }
    .table tbody tr { transition: background-color 0.2s ease; }
    .table tbody tr:hover { background-color: rgba(148, 163, 184, 0.1); }
  </style>
</head>
<body>
  <header class="header">
    <div class="container header-row">
      <div>
        <h1>Categorized CSV Flow</h1>
        <p class="sub">Select categorized CSVs from GitHub or upload one, then filter, group, pivot, and compare.</p>
      </div>
      <a href="/" class="btn">‚Üê Back</a>
    </div>
    <div class="accent-bar"></div>
  </header>

  <main class="container">
    {% if error %}<div class="alert error">{{ error }}</div>{% endif %}
    {% if info %}<div class="alert warn">{{ info }}</div>{% endif %}
<section class="card">
  <h2>Select categorized CSVs from GitHub</h2>
  <form id="cat-gh-form" action="/categorized-github" method="post" class="upload-form">
    <div class="file-input" style="align-items:flex-start; flex-direction:column;">
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:8px;width:100%;max-width:700px;">
        <div><label>Owner</label><input type="text" name="owner" id="gh-owner" placeholder="your-github-username" value="{{ GITHUB_OWNER or '' }}" required></div>
        <div><label>Repo</label><input type="text" name="repo" id="gh-repo" placeholder="your-repo-name" value="{{ GITHUB_REPO or '' }}" required></div>
        <div><label>Branch</label><input type="text" name="branch" id="gh-branch" value="{{ GITHUB_BRANCH or 'main' }}"></div>
        <div><label>Path (folder)</label><input type="text" id="gh-path" placeholder="data/categorized/"></div>
      </div>

      <button type="button" class="btn" id="gh-list-btn" style="margin-top:8px;">List CSVs</button>

      <div id="gh-list" class="table-wrap" style="display:none; margin-top:12px;">
        <div class="list-controls" style="display:flex;justify-content:flex-end;gap:8px;padding:8px;">
          <button type="button" class="btn" id="gh-select-all">Select All</button>
          <button type="button" class="btn" id="gh-clear">Clear</button>
          <span id="gh-count" class="badge"></span>
        </div>
        <table class="table">
          <thead><tr><th>Raw URL (click to select)</th></tr></thead>
          <tbody id="gh-tbody"></tbody>
        </table>
      </div>

      <label for="gh-urls" style="margin-top:12px;">Selected Raw URLs (one per line or comma-separated):</label>
      <textarea id="gh-urls" name="urls" rows="5" style="width:100%;max-width:700px;" placeholder="https://raw.githubusercontent.com/{owner}/{repo}/{branch}/path/file1.csv&#10;https://raw.githubusercontent.com/{owner}/{repo}/{branch}/path/file2.csv"></textarea>
    </div>

    <div class="actions">
      <button type="submit" class="btn primary">Analyze (Categorized)</button>
    </div>
  </form>
</section>

<section class="card">
  <h2>Upload a categorized CSV</h2>
  <form class="upload-form" action="/categorized-analyze" method="post" enctype="multipart/form-data">
    <div class="file-input">
      <label>
        <input type="file" name="file" style="display:none" accept=".csv">
        <span>Select CSV file</span>
      </label>
    </div>
    <div class="actions">
      <button type="submit" class="btn primary">Analyze (Upload)</button>
    </div>
  </form>
  <p class="tips">Expected columns: Month, CardName, MainCategory, Category, Description, Amount, Comment (Comment optional).</p>
</section>

{% if data_json %}
<section class="card">
  <div class="card-head">
    <h2>Data Filter, Group, Pivot & Compare</h2>
  </div>

  <div class="filter-row" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:8px;margin-bottom:12px;">
    <div><label>Month</label><select id="f-month" class="btn"></select></div>
    <div><label>CardName</label><select id="f-card" class="btn"></select></div>
    <div><label>MainCategory</label><select id="f-main" class="btn"></select></div>
    <div><label>Category</label><select id="f-cat" class="btn"></select></div>
  </div>

  <div class="group-row" style="display:flex;gap:12px;align-items:center;margin-bottom:12px;">
    <span class="badge">Group By:</span>
    <label><input type="checkbox" id="g-month"> Month</label>
    <label><input type="checkbox" id="g-card"> CardName</label>
    <label><input type="checkbox" id="g-main"> MainCategory</label>
    <label><input type="checkbox" id="g-cat"> Category</label>

    <span class="badge" style="margin-left:12px;">Aggregate:</span>
    <select id="agg" class="btn">
      <option value="sum">sum</option>
      <option value="mean">mean</option>
      <option value="count">count</option>
      <option value="min">min</option>
      <option value="max">max</option>
      <option value="median">median</option>
    </select>

    <button id="apply" class="btn primary" style="margin-left:auto;">Apply Filter</button>
    <button id="group" class="btn">Group By</button>
    <button id="pivot" class="btn">Pivot View</button>
    <button id="bars" class="btn">Bar Chart View</button>
    <button id="reset" class="btn">Reset</button>
  </div>

  <div id="results-label" class="badge"></div>

  <div class="table-wrap">
    <table class="table" id="out-table"><thead></thead><tbody></tbody></table>
  </div>
</section>
{% endif %}

    
  </main>

  <script>
    // ---------- GitHub CSV listing ----------
    function updateCount() {
      const textarea = document.getElementById('gh-urls');
      const urls = textarea.value.trim().split(/[\n,]+/).map(u => u.trim()).filter(Boolean);
      const badge = document.getElementById('gh-count');
      if (badge) badge.textContent = `${urls.length} selected`;
    }

    function addRow(rawUrl) {
      const tbody = document.getElementById('gh-tbody');
      const tr = document.createElement('tr');
      tr.style.cursor = 'pointer';
      tr.innerHTML = `<td>${rawUrl}</td>`;
      tr.addEventListener('click', function() {
        const textarea = document.getElementById('gh-urls');
        const current = textarea.value.trim();
        const urls = current ? current.split(/[\n,]+/).map(u => u.trim()).filter(Boolean) : [];
        const idx = urls.indexOf(rawUrl);
        if (idx >= 0) {
          urls.splice(idx, 1);
          tr.classList.remove('selected');
        } else {
          urls.push(rawUrl);
          tr.classList.add('selected');
        }
        textarea.value = urls.join('\n');
        updateCount();
      });
      tbody.appendChild(tr);
    }

    async function listCSVs() {
      const owner = document.getElementById('gh-owner').value.trim();
      const repo = document.getElementById('gh-repo').value.trim();
      const branch = document.getElementById('gh-branch').value.trim() || 'main';
      const path = document.getElementById('gh-path').value.trim();

      if (!owner || !repo) {
        alert('Please provide both Owner and Repo');
        return;
      }

      const btn = document.getElementById('gh-list-btn');
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Loading...';

      try {
        const params = new URLSearchParams({ owner, repo, branch, path });
        const resp = await fetch(`/gh-list?${params.toString()}`);
        const data = await resp.json();

        if (!resp.ok || data.error) {
          throw new Error(data.error || `GitHub list failed (${resp.status})`);
        }

        const items = Array.isArray(data.items) ? data.items : [];
        const tbody = document.getElementById('gh-tbody');
        tbody.innerHTML = '';

        if (items.length === 0) {
          alert('No CSV files found in the specified path');
        } else {
          items.forEach(rawUrl => addRow(rawUrl));
          document.getElementById('gh-list').style.display = 'block';
        }

        updateCount();
      } catch (e) {
        console.error('[gh-list] error:', e);
        alert(`Error fetching CSVs: ${e.message}`);
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    const btnList = document.getElementById('gh-list-btn'); if (btnList) btnList.addEventListener('click', listCSVs);
    const btnAll = document.getElementById('gh-select-all'); if (btnAll) btnAll.addEventListener('click', function() {
      const tbody = document.getElementById('gh-tbody');
      const rows = tbody.querySelectorAll('tr');
      const urls = [];
      rows.forEach(row => {
        row.classList.add('selected');
        const url = row.querySelector('td').textContent.trim();
        urls.push(url);
      });
      document.getElementById('gh-urls').value = urls.join('\n');
      updateCount();
    });
    const btnClear = document.getElementById('gh-clear'); if (btnClear) btnClear.addEventListener('click', function() {
      document.getElementById('gh-urls').value = '';
      const tbody = document.getElementById('gh-tbody');
      tbody.querySelectorAll('tr').forEach(row => row.classList.remove('selected'));
      updateCount();
    });
  const ghUrls = document.getElementById('gh-urls'); 
    if (ghUrls) ghUrls.addEventListener('input', updateCount); 
    updateCount();

    

    // ---------- Data dashboard (only runs when data_json exists) ----------
    {% if data_json %}
    document.addEventListener('DOMContentLoaded', () => {
      try {
        const rows = {{ data_json | tojson }};
        console.log('[categorized] rows length:', Array.isArray(rows) ? rows.length : 'not array', rows?.[0]);
        if (!Array.isArray(rows) || rows.length === 0) {
          const labelEl = document.getElementById('results-label'); if (labelEl) labelEl.textContent = 'No data rows to display.';
          return;
        }

        // Column adapter: maps actual CSV keys to logical names used by UI
        function buildFieldMap(sample){
          const norm = k => String(k || '').trim().toLowerCase();
          const keys = Object.keys(sample || {}).map(k => ({raw:k, n:norm(k)}));
          function findOne(candidates){
            for (const cand of candidates){
              const hit = keys.find(k => k.n === cand);
              if (hit) return hit.raw;
            }
            return null;
          }
          return {
            Month:        findOne(['month']),
            CardName:     findOne(['cardname','card_name','card name','card']),
            MainCategory: findOne(['maincategory','main_category','main category','main']),
            Category:     findOne(['category','subcat','sub category','subcategory']),
            Description:  findOne(['description','desc']),
            Amount:       findOne(['amount','amt','value','total','amount ($)', 'debit', 'credit']),
            Comment:      findOne(['comment','notes','note','remarks'])
          };
        }
        function getVal(row, logicalKey, fieldMap){
          const k = fieldMap[logicalKey];
          return k ? row[k] : undefined;
        }

        const fieldMap = buildFieldMap(rows[0] || {});
        console.log('[fieldMap]', fieldMap);
        console.log('Columns detected:', Object.keys(rows[0] || {}));
        const outTable = document.getElementById('out-table');

        function unique(arr){ return Array.from(new Set(arr)); }
        function selectFill(sel, values){
          sel.innerHTML = '';
          const optAll = document.createElement('option'); optAll.value = '__all__'; optAll.textContent = 'All'; sel.appendChild(optAll);
          values.forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = v; sel.appendChild(o); });
          sel.value = '__all__';
        }

        const sMonth = document.getElementById('f-month');
        const sCard  = document.getElementById('f-card');
        const sMain  = document.getElementById('f-main');
        const sCat   = document.getElementById('f-cat');

      selectFill(sMonth, unique(rows.map(r => String(getVal(r,'Month',fieldMap) ?? '').trim()).filter(v => v !== '')).sort((a,b)=>a.localeCompare(b))); 
      selectFill(sCard, unique(rows.map(r => String(getVal(r,'CardName',fieldMap) ?? '').trim()).filter(v => v !== '')).sort((a,b)=>a.localeCompare(b))); 
      selectFill(sMain, unique(rows.map(r => String(getVal(r,'MainCategory',fieldMap) ?? '').trim()).filter(v => v !== '')).sort((a,b)=>a.localeCompare(b))); 
      selectFill(sCat, unique(rows.map(r => String(getVal(r,'Category',fieldMap) ?? '').trim()).filter(v => v !== '')).sort((a,b)=>a.localeCompare(b)));

        // Force defaults to All (defensive)
          if (sMonth) sMonth.value='__all__';
          if (sCard) sCard.value='__all__'; 
          if (sMain) sMain.value='__all__'; 
          if (sCat) sCat.value='__all__';
      

        showFiltered();
      
        function renderTable(headers, data){
          const thead = outTable.querySelector('thead'); const tbody = outTable.querySelector('tbody');
          thead.innerHTML = ''; tbody.innerHTML = '';
          const trh = document.createElement('tr');
          headers.forEach(h => { const th = document.createElement('th'); th.textContent = h.text || h; trh.appendChild(th); });
          thead.appendChild(trh);
          data.forEach(r => {
            const tr = document.createElement('tr');
            headers.forEach(h => {
              const key = h.key || h;
              const td = document.createElement('td');
              const v = r[key];
              td.textContent = v != null ? v : '';
              if (h.class) td.className = h.class;
              tr.appendChild(td);
            });
            tbody.appendChild(tr);
          });
        }

       function filtered(){
         let out = rows.slice(); 
         const norm = v => String(v ?? '').trim(); 
         const fm = sMonth ? sMonth.value : '__all__'; 
         const fc = sCard ? sCard.value : '__all__'; 
         const fma = sMain ? sMain.value : '__all__'; 
         const fca = sCat ? sCat.value : '__all__';

        if (fm !== '__all__' && fieldMap.Month) out = out.filter(r => norm(getVal(r,'Month',fieldMap)) === norm(fm)); 
         if (fc !== '__all__' && fieldMap.CardName) out = out.filter(r => norm(getVal(r,'CardName',fieldMap)) === norm(fc)); 
         if (fma !== '__all__' && fieldMap.MainCategory) out = out.filter(r => norm(getVal(r,'MainCategory',fieldMap)) === norm(fma)); 
         if (fca !== '__all__' && fieldMap.Category) out = out.filter(r => norm(getVal(r,'Category',fieldMap)) === norm(fca));

       console.log('Filter state:', {
            fm, fc, fma, fca,
            sample: out.slice(0,3).map(r => ({
            Month:        String(getVal(r,'Month',fieldMap)        ?? '').trim(),
            CardName:     String(getVal(r,'CardName',fieldMap)     ?? '').trim(),
            MainCategory: String(getVal(r,'MainCategory',fieldMap) ?? '').trim(),
          Category:     String(getVal(r,'Category',fieldMap)     ?? '').trim(),
          }))
          });

        return out;
       }
 

        function showFiltered(){
          const data = filtered();
          const labelEl = document.getElementById('results-label'); if (labelEl) labelEl.textContent = `Showing ${data.length} of ${rows.length} rows`;
          const headers = [
            {text:'Month',        key: fieldMap.Month        || 'Month'},
            {text:'CardName',     key: fieldMap.CardName     || 'CardName'},
            {text:'MainCategory', key: fieldMap.MainCategory || 'MainCategory'},
            {text:'Category',     key: fieldMap.Category     || 'Category'},
            {text:'Description',  key: fieldMap.Description  || 'Description'},
            {text:'Amount',       key: fieldMap.Amount       || 'Amount', class:'num'},
            {text:'Comment',      key: fieldMap.Comment      || 'Comment'}
          ];
          renderTable(headers, data);
        }

        const gMonth = document.getElementById('g-month');
        const gCard = document.getElementById('g-card');
        const gMain = document.getElementById('g-main');
        const gCat = document.getElementById('g-cat');
        const aggSel = document.getElementById('agg');

        function aggregate(vals, method){
          if (method === 'count') return vals.length;
          if (method === 'sum') return vals.reduce((a,b)=>a+b,0);
          const sorted = vals.slice().sort((a,b)=>a-b);
          if (method === 'min') return sorted[0] || 0;
          if (method === 'max') return sorted[sorted.length-1] || 0;
          if (method === 'mean') return vals.length ? (vals.reduce((a,b)=>a+b,0) / vals.length) : 0;
          if (method === 'median'){
            if (!vals.length) return 0;
            const mid = Math.floor(sorted.length/2);
            return sorted.length % 2 ? sorted[mid] : (sorted[mid-1] + sorted[mid])/2;
          }
          return vals.reduce((a,b)=>a+b,0);
        }

      function parseAmt(row, fieldMap){ 
        const k = fieldMap.Amount || 'Amount'; const raw = row[k]; const v = typeof raw === 'number' ? raw : parseFloat(String(raw).replace(/[, ]/g,'')); 
        return Number.isFinite(v) ? v : 0; 
      }

        function groupBy(){
          const data = filtered();
          const cols = [];
          if (gMonth.checked) cols.push('Month');
          if (gCard.checked)  cols.push('CardName');
          if (gMain.checked)  cols.push('MainCategory');
          if (gCat.checked)   cols.push('Category');
          if (!cols.length){
            const labelEl = document.getElementById('results-label'); if (labelEl) labelEl.textContent = 'Please select at least one column to group by';
            return;
          }

          const agg = aggSel.value;
          let grouped = {};
          data.forEach(r => {
            const keyVals = cols.map(c => String(getVal(r, c, fieldMap)));
            const key = keyVals.join('||');
            if (!grouped[key]) grouped[key] = {__keys: keyVals, Amounts: []};
            grouped[key].Amounts.push(parseAmt(r, fieldMap));
          });

          const rowsOut = Object.values(grouped).map(g => {
            const aggVal = aggregate(g.Amounts, agg);
            const row = {};
            cols.forEach((c,i) => { row[c] = g.__keys[i]; });
            row[`Amount_${agg}`] = Number(aggVal.toFixed(2));
            return row;
          });

          const headers = cols.map(c => ({text:c, key:c})).concat([{text:`Amount_${agg}`, key:`Amount_${agg}`, class:'num'}]);
          const labelEl = document.getElementById('results-label'); if (labelEl) labelEl.textContent = `Grouped by: ${cols.join(', ')} | Method: ${agg.toUpperCase()} | Rows: ${rowsOut.length}`;
          renderTable(headers, rowsOut);
        }

        function makePivot(rowsOut, rowKey, colKey, valKey){
          const rowVals = Array.from(new Set(rowsOut.map(r => r[rowKey]))).sort();
          const colVals = Array.from(new Set(rowsOut.map(r => r[colKey]))).sort();
          const lookup = {};
          rowsOut.forEach(r => {
            const rk = r[rowKey], ck = r[colKey];
            const v = Number(r[valKey]) || 0;
            lookup[`${rk}||${ck}`] = v;
          });
          const headers = [{text: rowKey, key: rowKey}].concat(colVals.map(c => ({text: c, key: c, class:'num'})));
          const data = rowVals.map(rv => {
            const row = {};
            row[rowKey] = rv;
            colVals.forEach(cv => {
              row[cv] = lookup[`${rv}||${cv}`] != null ? Number(lookup[`${rv}||${cv}`]).toFixed(2) : '';
            });
            return row;
          });
          return {headers, data, rowVals, colVals};
        }

        function pivotView(){
          const data = filtered();
          const cols = [];
          if (gMonth.checked) cols.push('Month');
          if (gCard.checked) cols.push('CardName');
          if (gMain.checked) cols.push('MainCategory');
          if (gCat.checked) cols.push('Category');
          const agg = aggSel.value;

          if (cols.length < 2){
            const labelEl = document.getElementById('results-label'); if (labelEl) labelEl.textContent = 'Pivot requires at least two Group By columns (e.g., Month and MainCategory).';
            return;
          }

          let grouped = {};
          data.forEach(r => {
            const key = cols.map(c => String(getVal(r, c, fieldMap))).join('||');
            if (!grouped[key]) grouped[key] = {__keys: cols.map(c => String(getVal(r, c, fieldMap))), Amounts: []};
            grouped[key].Amounts.push(parseAmt(r, fieldMap));
          });

          const rowsOut = Object.values(grouped).map(g => {
            const aggVal = aggregate(g.Amounts, agg);
            const row = {};
            cols.forEach((c,i) => { row[cols[i]] = g.__keys[i]; });
            row[`Amount_${agg}`] = Number(aggVal.toFixed(2));
            return row;
          });

          const rowKey = cols[0], colKey = cols[1], valKey = `Amount_${agg}`;
          const pivot = makePivot(rowsOut, rowKey, colKey, valKey);
          const labelEl = document.getElementById('results-label'); if (labelEl) labelEl.textContent = `Pivot: rows=${rowKey}, cols=${colKey}, agg=${agg.toUpperCase()} | Rows: ${pivot.data.length}`;
          renderTable(pivot.headers, pivot.data);
        }

        function barChartView(){
          const data = filtered();
          const cols = [];
          if (gMonth.checked) cols.push('Month');
          if (gCard.checked) cols.push('CardName');
          if (gMain.checked) cols.push('MainCategory');
          if (gCat.checked) cols.push('Category');
          const agg = aggSel.value;

          if (cols.length < 2){
            const labelEl = document.getElementById('results-label'); if (labelEl) labelEl.textContent = 'Bar Chart view requires at least two Group By columns (e.g., Month and MainCategory).';
            return;
          }

          let grouped = {};
          data.forEach(r => {
            const key = cols.map(c => String(getVal(r, c, fieldMap))).join('||');
            if (!grouped[key]) grouped[key] = {__keys: cols.map(c => String(getVal(r, c, fieldMap))), Amounts: []};
            grouped[key].Amounts.push(parseAmt(r, fieldMap));
          });

          const rowsOut = Object.values(grouped).map(g => {
            const aggVal = aggregate(g.Amounts, agg);
            const row = {};
            cols.forEach((c,i) => { row[cols[i]] = g.__keys[i]; });
            row[`Amount_${agg}`] = Number(aggVal.toFixed(2));
            return row;
          });

          const rowKey = cols[0], colKey = cols[1], valKey = `Amount_${agg}`;
          const pivot = makePivot(rowsOut, rowKey, colKey, valKey);

          const outTable = document.getElementById('out-table');
          const thead = outTable.querySelector('thead'), tbody = outTable.querySelector('tbody');
          thead.innerHTML = ''; tbody.innerHTML = '';

          const allVals = [];
          pivot.data.forEach(row => pivot.colVals.forEach(c => {
            const v = parseFloat(row[c]);
            if (!isNaN(v)) allVals.push(v);
          }));
          const maxVal = Math.max(...allVals, 1);

          const trh = document.createElement('tr');
          const thLabel = document.createElement('th'); thLabel.textContent = rowKey; trh.appendChild(thLabel);
          const thChart = document.createElement('th'); thChart.textContent = 'Values'; trh.appendChild(thChart);
          thead.appendChild(trh);

          pivot.data.forEach(row => {
            const tr = document.createElement('tr');
            const tdLabel = document.createElement('td'); tdLabel.textContent = row[rowKey]; tr.appendChild(tdLabel);
            const tdBars = document.createElement('td');

            const grid = document.createElement('div');
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = 'repeat(auto-fit, minmax(160px, 1fr))';
            grid.style.gap = '6px';

            pivot.colVals.forEach(series => {
              const v = parseFloat(row[series]);
              const wrap = document.createElement('div');
              const label = document.createElement('div');
              label.textContent = `${series}: ${isNaN(v) ? '-' : v.toFixed(2)}`;
              label.style.color = 'var(--muted)';
              const bar = document.createElement('div');
              bar.style.height = '10px';
              bar.style.background = 'linear-gradient(90deg, #22c55e, #06b6d4)';
              bar.style.border = '1px solid var(--border)';
              bar.style.borderRadius = '6px';
              bar.style.width = isNaN(v) ? '0px' : `${Math.round((v / maxVal) * 220)}px`;
              wrap.appendChild(label);
              wrap.appendChild(bar);
              grid.appendChild(wrap);
            });

            tdBars.appendChild(grid);
            tr.appendChild(tdBars);
            tbody.appendChild(tr);
          });

          const labelEl = document.getElementById('results-label'); if (labelEl) labelEl.textContent = `Bars: ${rowKey} vs ${colKey} (agg=${agg.toUpperCase()}) | Max=${maxVal.toFixed(2)}`;
        }

        document.getElementById('apply').addEventListener('click', showFiltered);
        document.getElementById('group').addEventListener('click', groupBy);
        document.getElementById('pivot').addEventListener('click', pivotView);
        document.getElementById('bars').addEventListener('click', barChartView);
        document.getElementById('reset').addEventListener('click', () => {
          [sMonth,sCard,sMain,sCat].forEach(sel => sel.value='__all__');
          [gMonth,gCard,gMain,gCat].forEach(cb => cb.checked=false);
          aggSel.value='sum';
          showFiltered();
        });

        showFiltered();
      } catch (e) {
        console.error('[categorized] init error:', e);
        const labelEl = document.getElementById('results-label'); if (labelEl) labelEl.textContent = `Error initializing dashboard: ${e.message}`;
      }
    });
    {% endif %}
  </script>
</body>
</html>
